# 用户登录功能 - 技术设计文档

**需求编号**: REQ-LOGIN-001
**文档版本**: v1.0
**创建日期**: 2025-01-02

## 1. 功能概述

实现用户登录功能，支持用户名/手机号/邮箱三种登录方式，包含密码加密传输、错误次数限制、账户锁定、记住密码等核心功能。

## 2. 技术实现方案

### 2.1 前端实现

#### 抄件位置
`src/views/auth/Login.vue`

#### 核心逻辑
1. **登录表单**：
   - 使用Element UI的Form组件
   - 表单验证：用户名1-50字符，密码6-20字符
   - 支持回车键提交

2. **密码加密**：
   - 使用JSEncrypt库进行RSA加密
   - 公钥从后端接口获取：`GET /api/auth/rsa-public-key`
   - 登录前先对密码进行加密

3. **Token存储**：
   - 登录成功后，将JWT Token存储在localStorage
   - Token格式：`Bearer {token}`
   - 使用axios拦截器自动添加Token到请求头

4. **记住密码**：
   - 勾选时，将加密后的用户名和密码存储在localStorage（7天有效期）
   - 下次访问时自动填充并登录
   - 退出登录时清除本地凭证

#### 状态管理
```javascript
// store/modules/user.js
const state = {
  token: localStorage.getItem('token') || '',
  userInfo: null
}

const mutations = {
  SET_TOKEN(state, token) {
    state.token = token
    localStorage.setItem('token', token)
  },
  SET_USER_INFO(state, userInfo) {
    state.userInfo = userInfo
  },
  CLEAR_AUTH(state) {
    state.token = ''
    state.userInfo = null
    localStorage.removeItem('token')
    localStorage.removeItem('rememberMe')
  }
}
```

### 2.2 后端实现

#### Controller层
```java
@RestController
@RequestMapping("/api/auth")
public class AuthController {

    @Autowired
    private AuthService authService;

    /**
     * 获取RSA公钥
     */
    @GetMapping("/rsa-public-key")
    public Result<String> getRsaPublicKey() {
        String publicKey = authService.getRsaPublicKey();
        return Result.success(publicKey);
    }

    /**
     * 用户登录
     */
    @PostMapping("/login")
    public Result<LoginResponse> login(@RequestBody LoginRequest request) {
        LoginResponse response = authService.login(request);
        return Result.success(response);
    }
}
```

#### Service层核心逻辑

**登录流程**：
1. RSA解密密码
2. 根据用户名/手机号/邮箱查询用户
3. 验证用户状态（是否冻结、删除）
4. 验证密码（使用BCrypt）
5. 检查登录失败次数，超过3次则锁定账户
6. 登录成功：
   - 生成JWT Token（2小时有效期）
   - 清除登录失败次数
   - 记录登录日志
7. 登录失败：
   - 增加失败次数
   - 记录失败日志
   - 3次后锁定账户30分钟

**账户锁定机制**：
```java
// 使用Redis存储登录失败次数和锁定状态
// Key格式：login:fail:{username}
// 锁定时间：30分钟
String failKey = "login:fail:" + username;
Integer failCount = redisTemplate.opsForValue().get(failKey);

if (failCount != null && failCount >= 3) {
    // 检查是否还在锁定期内
    Long ttl = redisTemplate.getExpire(failKey, TimeUnit.SECONDS);
    if (ttl > 0) {
        throw new AccountLockedException("账户已锁定，请" + ttl/60 + "分钟后再试");
    }
}
```

**密码验证**：
```java
// 使用BCrypt验证密码
boolean matches = passwordEncoder.matches(rawPassword, encodedPassword);
```

**JWT Token生成**：
```java
String token = Jwts.builder()
    .setSubject(user.getUserId().toString())
    .setIssuedAt(new Date())
    .setExpiration(new Date(System.currentTimeMillis() + 7200 * 1000))
    .signWith(SignatureAlgorithm.HS256, secretKey)
    .compact();
```

#### 数据库设计

**用户表（t_user）**：
```sql
CREATE TABLE t_user (
  user_id BIGINT PRIMARY KEY AUTO_INCREMENT COMMENT '用户ID',
  username VARCHAR(50) UNIQUE NOT NULL COMMENT '用户名',
  phone VARCHAR(20) UNIQUE COMMENT '手机号',
  email VARCHAR(100) UNIQUE COMMENT '邮箱',
  password VARCHAR(100) NOT NULL COMMENT 'BCrypt加密后的密码',
  nickname VARCHAR(50) COMMENT '昵称',
  status TINYINT DEFAULT 1 COMMENT '状态：1-正常，0-冻结，-1-删除',
  create_time DATETIME DEFAULT CURRENT_TIMESTAMP,
  update_time DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  INDEX idx_username(username),
  INDEX idx_phone(phone),
  INDEX idx_email(email)
) COMMENT='用户表';
```

**登录日志表（t_login_log）**：
```sql
CREATE TABLE t_login_log (
  log_id BIGINT PRIMARY KEY AUTO_INCREMENT,
  user_id BIGINT COMMENT '用户ID',
  login_time DATETIME COMMENT '登录时间',
  login_ip VARCHAR(50) COMMENT '登录IP',
  login_status TINYINT COMMENT '登录状态：1-成功，0-失败',
  fail_reason VARCHAR(200) COMMENT '失败原因',
  user_agent VARCHAR(500) COMMENT '浏览器信息',
  INDEX idx_user_id(user_id),
  INDEX idx_login_time(login_time)
) COMMENT='登录日志表';
```

### 2.3 安全实现

#### 密码加密传输
1. 前端获取RSA公钥：`GET /api/auth/rsa-public-key`
2. 前端使用公钥加密密码
3. 后端使用私钥解密
4. RSA密钥对定期轮换（建议每月）

#### 防暴力破解
1. 登录失败3次锁定账户30分钟
2. 锁定后显示图形验证码
3. 记录所有失败尝试到日志
4. 短时间内大量失败尝试触发告警

#### SQL注入防护
1. 使用MyBatis的预编译语句
2. 参数化查询，不拼接SQL
3. 输入验证：用户名只允许字母数字下划线

#### XSS防护
1. 后端对用户输入进行HTML转义
2. 前端使用Vue的自动转义机制
3. Cookie设置HttpOnly标志

#### CSRF防护
1. 使用JWT Token，不依赖Cookie
2. 重要操作使用POST请求
3. 验证Referer头

### 2.4 性能优化

#### 缓存策略
1. Redis缓存用户信息（Key: `user:info:{userId}`，TTL: 30分钟）
2. Redis缓存登录失败次数（Key: `login:fail:{username}`，TTL: 30分钟）
3. RSA公钥缓存（避免每次登录都获取）

#### 并发处理
1. 使用Redis的原子操作保证登录失败次数的准确性
2. 使用分布式锁防止并发登录导致的数据不一致
3. 数据库连接池优化（HikariCP）

#### 响应时间优化
1. 目标：登录接口响应时间 < 500ms
2. 数据库查询优化：为username、phone、email建立索引
3. 减少不必要的数据库查询（如登录失败不查询用户详细信息）

### 2.5 异常处理

#### 异常类型
```java
public class UserNotFoundException extends RuntimeException {
    // 用户不存在
}

public class PasswordErrorException extends RuntimeException {
    // 密码错误
}

public class AccountLockedException extends RuntimeException {
    // 账户已锁定
    private Long lockedUntil; // 锁定截止时间
}

public class AccountFrozenException extends RuntimeException {
    // 账户已冻结
}
```

#### 统一异常处理
```java
@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(UserNotFoundException.class)
    public Result<?> handleUserNotFound(UserNotFoundException e) {
        return Result.error(401, "用户名或密码错误");
    }

    @ExceptionHandler(AccountLockedException.class)
    public Result<?> handleAccountLocked(AccountLockedException e) {
        Map<String, Object> data = new HashMap<>();
        data.put("locked_until", e.getLockedUntil());
        data.put("remaining_minutes", (e.getLockedUntil() - System.currentTimeMillis()) / 60000);
        return Result.error(423, "账户已锁定，请30分钟后再试", data);
    }
}
```

### 2.6 测试要点

#### 单元测试
- 密码加密/解密测试
- Token生成/解析测试
- 登录失败次数累加测试
- 账户锁定时间计算测试

#### 接口测试
- 正常登录测试
- 用户名不存在测试
- 密码错误测试（1次、2次、3次）
- 账户锁定后登录测试
- 冻结账户登录测试
- Token过期测试

#### 安全测试
- SQL注入测试
- 暴力破解测试
- 密码传输加密测试
- 越权访问测试

#### 性能测试
- 100并发登录测试
- 接口响应时间测试
- Redis缓存命中率测试

## 3. 关键技术点

### 3.1 BCrypt密码加密
- 加密因子：10
- 每次加密结果不同，但验证时可以匹配
- 示例：`$2a$10$N9qo8uLOickgx2ZMRZoMyeIjZAgcfl7p92ldGxad68LJZdL17lhWy`

### 3.2 JWT Token
- Header: `{"alg": "HS256", "typ": "JWT"}`
- Payload: `{"sub": "10001", "iat": 1704211200, "exp": 1704218400}`
- Signature: HMACSHA256(Base64UrlEncode(Header) + "." + Base64UrlEncode(Payload), secret)

### 3.3 RSA加密
- 密钥大小：2048位
- 加密模式：RSA/ECB/PKCS1Padding
- 公钥用于前端加密，私钥用于后端解密

## 4. 依赖关系

### 前置依赖
- 用户注册功能（REQ-REGISTER-001）：用户必须先注册才能登录

### 后续功能依赖
- 退出登录（REQ-LOGOUT-001）：清除Token和本地凭证
- 修改密码（REQ-CHGPWD-001）：用户可以修改自己的密码
- 权限管理（REQ-PERMISSION-001）：根据用户角色分配权限

## 5. 部署说明

### 环境变量
```
JWT_SECRET=your-secret-key-here
RSA_PRIVATE_KEY=MIGfMA0GCsq...
RSA_PUBLIC_KEY=MIGfMA0GCs...
REDIS_HOST=localhost
REDIS_PORT=6379
REDIS_PASSWORD=
```

### Nginx配置
```nginx
location /api/ {
    proxy_pass http://backend:8080;
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
}
```

## 6. 监控和日志

### 日志记录
- 所有登录尝试（成功和失败）
- 账户锁定事件
- 异常登录行为（短时间大量失败）
- Token生成和验证

### 监控指标
- 登录成功率
- 登录接口响应时间
- 账户锁定次数
- 异常登录行为次数
